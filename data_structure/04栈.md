# 栈

## 1.概述

- 介绍

  ![image-20211029151142860](images/image-20211029151142860.png)

- 应用场景

  ![image-20211029151520783](images/image-20211029151520783.png)



## 2.代码实现

- 思路分析：

  ![image-20211029151922708](images/image-20211029151922708.png)

  

- ```java
  public class ArrayStackDemo {
      public static void main(String[] args){
          ArrayStack arrayStack = new ArrayStack(4);
          String key = "";
          boolean loop = true;
          Scanner scanner = new Scanner(System.in);
          while(loop){
              System.out.println("show: 显示栈");
              System.out.println("exit");
              System.out.println("push");
              System.out.println("pop");
              key = scanner.next();
              switch (key){
                  case "show":
                      arrayStack.list();
                      break;
                  case "push":
                      int value = scanner.nextInt();
                      arrayStack.push(value);
                      break;
                  case "pop":
                      try{
                          int res = arrayStack.pop();
                          System.out.println(res);
                      }catch (Exception e){
                          System.out.println(e.getMessage());
                      }
                  case "exit":
                     scanner.close();
                     loop = false;
                     break;
                  default:
                      break;
              }
          }
      }
  }
  class ArrayStack{
      private int maxSize;
      private int[] stack;
      private int top = -1;
      public ArrayStack(int maxSize){
          this.maxSize = maxSize;
          stack = new int[this.maxSize];
      }
      //栈满
      public boolean isFull(){
          return top == maxSize - 1;
      }
      public boolean isEmpty(){
          return top == -1;
      }
      public void push(int value){
          if(isFull()){
              System.out.println("full");
              return;
          }
          top++;
          stack[top] = value;
      }
      public int pop(){
          if(isEmpty()){
              throw new RuntimeException("empty");
          }
          int value = stack[top];
          top--;
          return value;
      }
      public void list(){
          if(isEmpty()){
              System.out.println("empty");
              return;
          }
          for(int i = top; i >= 0; i--){
              System.out.println(stack[i]);
          }
      }
  }
  ```

## 2.栈实现综合计算器

- 思路分析

  ![image-20211029155205617](images/image-20211029155205617.png)

- 代码实现：

  ```java
  public class Calculator {
      public static void main(String[] args){
          String expression = "30+2*6-2";
          ArrayStack2 numStack = new ArrayStack2(10);
          ArrayStack2 operStack = new ArrayStack2(10);
          int index = 0;
          int num1 = 0;
          int num2 = 0;
          int oper = 0;
          int res = 0;
          char ch = ' ';
          String keepNum = "";
          while(true){
              ch = expression.substring(index, index + 1).charAt(0);
              if(operStack.isOper(ch)){
                  if(operStack.isEmpty()){
                      operStack.push(ch);
                  }else{
                      if(operStack.priority(ch) <= operStack.priority(operStack.peek())){
                          num1 = numStack.pop();
                          num2 = numStack.pop();
                          oper = operStack.pop();
                          res = numStack.cal(num1, num2, oper);
                          numStack.push(res);
                          operStack.push(ch);
                      }else {
                          operStack.push(ch);
                      }
                  }
              }else{
                  keepNum += ch;
                  if(index == expression.length()-1){
                      numStack.push(Integer.parseInt(keepNum));
                  }else{
                      if(operStack.isOper(expression.substring(index+1, index+2).charAt(0))){
                          numStack.push(Integer.parseInt(keepNum));
                          keepNum = "";
                      }
                  }
              }
              index++;
              if(index >= expression.length()){
                  break;
              }
          }
          while(true){
              if(operStack.isEmpty())
                  break;
              num1 = numStack.pop();
              num2 = numStack.pop();
              oper = operStack.pop();
              res = numStack.cal(num1, num2, oper);
              numStack.push(res);
          }
          System.out.println(numStack.pop());
      }
  }
  
  class ArrayStack2{
      private int maxSize;
      private int[] stack;
      private int top = -1;
      public ArrayStack2(int maxSize){
          this.maxSize = maxSize;
          stack = new int[this.maxSize];
      }
      //栈满
      public boolean isFull(){
          return top == maxSize - 1;
      }
      public boolean isEmpty(){
          return top == -1;
      }
      public void push(int value){
          if(isFull()){
              System.out.println("full");
              return;
          }
          top++;
          stack[top] = value;
      }
      public int pop(){
          if(isEmpty()){
              throw new RuntimeException("empty");
          }
          int value = stack[top];
          top--;
          return value;
      }
      public void list(){
          if(isEmpty()){
              System.out.println("empty");
              return;
          }
          for(int i = top; i >= 0; i--){
              System.out.println(stack[i]);
          }
      }
      //返回运算符优先级
      public int priority(int oper){
          if(oper == '*' || oper == '/'){
              return 1;
          }else if(oper == '+' || oper == '-'){
              return 0;
          }else{
              return -1;
          }
      }
      //判断是否为运算符
      public boolean isOper(char val){
          return val == '+' || val == '-' || val == '*' || val == '/';
      }
      public int peek(){
          return stack[top];
      }
      //计算方法
      public int cal(int num1, int num2, int oper){
          int res = 0;
          switch (oper){
              case '+':
                  res = num1 + num2;
                  break;
              case '-':
                  res = num2 - num1;
                  break;
              case '*':
                  res = num1 * num2;
                  break;
              case '/':
                  res = num1 / num2;
                  break;
              default:
                  break;
          }
          return res;
      }
  }
  ```

## 3.前缀、中缀、后缀表达式（逆波兰表达式）

#### 1.前缀表达式

- 又称波兰式，运算符位于操作数之前
- 举例：![image-20211029165206004](images/image-20211029165206004.png)
- ![image-20211029165458271](images/image-20211029165458271.png)



#### 2.中缀表达式

- ![image-20211029165656620](images/image-20211029165656620.png)



#### 3.后缀表达式

- ![image-20211029165843806](images/image-20211029165843806.png)

- ![image-20211029165951222](images/image-20211029165951222.png)

- ```java
  import java.util.ArrayList;
  import java.util.List;
  import java.util.Stack;
  
  public class PolandNotation {
      public static void main(String[] args){
          String suffixExpression = "3 4 + 5 * 6 -";
          List<String> rpnList = getListString(suffixExpression);
          System.out.println(rpnList);
          int res = calculate(rpnList);
          System.out.println(res);
      }
      public static List<String> getListString(String suffixExpression){
          String[] split = suffixExpression.split(" ");
          List<String> list = new ArrayList<String>();
          for(String ele: split){
              list.add(ele);
          }
          return list;
      }
      public static int calculate(List<String> ls){
          Stack<String> stack = new Stack<String>();
          for(String item: ls){
              //正则表达式取出数
              if(item.matches("\\d+")){//匹配的是多位数
                  stack.push(item);
              }else{
                  int num2 = Integer.parseInt(stack.pop());
                  int num1 = Integer.parseInt(stack.pop());
                  int res = 0;
                  if(item.equals("+")){
                      res = num1 + num2;
                  }else if(item.equals("-")){
                      res = num1 - num2;
                  }else if(item.equals("*")){
                      res = num1 * num2;
                  }else if(item.equals("/")){
                      res = num1 / num2;
                  }else{
                      throw new RuntimeException("WRONG");
                  }
                  stack.push("" + res);
              }
          }
          return Integer.parseInt(stack.pop());
      }
  }
  ```

#### 4.中缀表达式转后缀表达式

- ![image-20211030180953821](images/image-20211030180953821.png)

- ```java
      //将中缀表达式转换成对应的List
      public static List<String> toInfixExpressionList(String s){
          List<String> ls = new ArrayList<String>();
          int i = 0;//指针，用于遍历 中缀表达式字符串
          String str; //对多位数的拼接
          char c;//每遍历到一个字符，就放入c中
          do{
              if((c = s.charAt(i)) < 48 || (c = s.charAt(i)) > 57){
                  ls.add("" + c);
                  i++;
              }else {//如果是数字，考虑多位数问题
                  str = "";
                  while(i < s.length() && (c = s.charAt(i)) >= 48 && (c = s.charAt(i)) <= 57){
                      str += c;
                      i++;
                  }
                  ls.add(str);
              }
          }while(i < s.length());
          return ls;
      }
  
  //方法：将得到的中缀表达式对应的List，转化成后缀表达式对应的List
      public static List<String> parseSuffixExpressionList(List<String> ls){
          Stack<String> s1 = new Stack<String>(); //符号栈
         // Stack<String> s2 = new Stack<String>(); 存储中间结果的栈
          List<String> s2 = new ArrayList<String>();
          for(String item: ls){
              if(item.matches("\\d+")){
                  s2.add(item);
              }else if(item.equals("(")){
                  s1.push(item);
              }else if(item.equals(")")){
                  while(!s1.peek().equals("(")){
                      s2.add(s1.pop());
                  }
                  s1.pop();//将（弹出
              }else{
                  while(s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item)){
                      s2.add(s1.pop());
                  }
                  s1.push(item);
              }
          }
          while(s1.size() != 0){
              s2.add(s1.pop());
          }
          return s2;
      }
  ```
