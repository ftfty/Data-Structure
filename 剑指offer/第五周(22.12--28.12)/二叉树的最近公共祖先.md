# 剑指offer 68 - II. 二叉树的最近公共祖先

### 题目地址：[二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)



### 题目描述：

>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
>



### 解答方法：

1. 

```java
//保存两个二叉树到指定结点的轨迹
//然后遍历找到最后一个相同的结点
LinkedList<TreeNode> stack1 = new LinkedList<>();
LinkedList<TreeNode> stack2 = new LinkedList<>();
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    TreeNode res1 = null,res2,tmp=null;
    dfs(stack1, root, p);
    dfs(stack2, root, q);
    int n = Math.min(stack1.size(), stack2.size());
    for(int i = 0; i < n; i++){
        res1 = stack1.pop();
        res2 = stack2.pop();
        if(res1.val == res2.val){
            tmp = res1;
        }
    }
    return tmp;
}
public void dfs(Deque<TreeNode> stack,TreeNode root, TreeNode p){
    if(root == null){
        return;
    }
    stack.addLast(root);
    if(root.val == p.val){
        return ;
    }
    dfs(stack, root.left, p);
    dfs(stack, root.right, p);
    if(stack.peekLast().val != p.val)stack.pollLast();
}
```

> 思路二 : ( 后序遍历

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || p == root || q == root){
            return root ;
        }
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        //left为空，则pq都在右子树，反之，亦同
        return left == null ? right : (right == null ? left : root);
    }
}
```

