# 剑指offer 07. 重建二叉树

### 题目地址：[重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)



### 题目描述：

>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。
>
>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。



### 解答方法 ：(

![image-20220104193655152](images/image-20220104193655152-16413039449252.png)

1. 递归

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
    }

    public TreeNode build(int[] preorder, int preL, int preR, int[] inorder, int inL, int inR){
        if(preL > preR || inL > inR) return null;
        int root = preorder[preL];
        int temp = inL;
        //temp : 中序数组对应的下标值
        while(root != inorder[temp]){
            temp++;
        }
        TreeNode node = new TreeNode(root);
        /*
         *1. 左右子树 递归时 边界值不要忘记+1
         *2. node.right ，先序中，要减去左子树的个数，这个个数要 “-inL”，因为不是从0开始的
         */
        node.left = build(preorder, preL + 1, preR -(inR - temp), inorder, inL, temp - 1);
        node.right = build(preorder, preL +  (temp-inL) + 1, preR, inorder, temp+1, inR);
        return node;
    }
}
```

> 思路二：哈希表优化
>
> - hashmap存储中序数组 值和下标 的映射
> - 减少了while循环的时间
> - 用的时候 hashmap.get(root) 获取下标
>
> 代码



