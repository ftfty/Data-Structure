# 剑指offer 55 - II. 平衡二叉树

### 题目地址：[平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)



### 题目描述：

>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。



### 解答方法：

1. 

```java
:( 好多重复计算
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root == null)return true;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()){
            TreeNode tmp = queue.poll();
            if(!(dfs(tmp.right)-dfs(tmp.left) <= 1 && (dfs(tmp.right)-dfs(tmp.left)) >= -1)){
                return false;
            }else{
                if (tmp.right != null)queue.add(tmp.right);
                if(tmp.left != null) queue.add(tmp.left);
            }
        }
        return true;
    }
    public int dfs(TreeNode root){
        if(root == null) return 0;
        else
            return 1+Math.max(dfs(root.right),dfs(root.left));
    }
}
```

> 改进思路：
>
> - 不用队列，直接递归就行
>
>     ```java
>     return Math.abs(dfs(root.left) - dfs(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
>     ```
>
> - 后序遍历 + 剪枝

> 思路二：后序遍历 + 剪枝
>
> ```java
> //不太理解 :(
> class Solution {
>     public boolean isBalanced(TreeNode root) {
>         return LRD(root) != -1;
>     }
>     public int LRD(TreeNode root){
>         if(root == null) return 0;
> 
>         int left = LRD(root.left);
>         int right = LRD(root.right);
> 
>         if(left == -1 || right == -1 || Math.abs(left - right)+1 > 2){
>             return -1;
>         }else
>         return Math.max(right,left)+1;
>     }
> }
> ```
>
> 