# 剑指offer 48. 最长不含重复字符的子字符串

### 题目地址：[最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)



### 题目描述：

>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。



### 解答方法：

1. 

- 用哈希表判断字符是否重复
- 用count记录遍历时每个子字符串的长度
- 如果重复的话，判断这次的长度是不是大于max
- 再将重复字符前的字符都从哈希表删除，并将count重新计算、

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        HashMap<Character,Integer> hashMap = new HashMap(s.length());
        //max : 第n - 1个子字符串前的最大值
        //count ： 当前记录子字符串的长度
        int max = 0,count = 0;
        //遍历字符串
        for (int i = 0; i < s.length(); i++) {
            //不存在键值则直接把对应的字符和下标存在哈希表里，并将count++，记录长度
            if(!hashMap.containsKey(s.charAt(i))){
                hashMap.put(s.charAt(i),i);
                count++;
            }else{
                //发生重复的情况
                //判断此次字符串是否最最长的一次
                if(count > max){
                    max = count;
                }
                //将重复字符前的所有字符都移除哈希表，边界值改了好久。。。:(
                for (int j = i - count ; j < hashMap.get(s.charAt(i)); j++) {
                    hashMap.remove(s.charAt(j));
                }
                //count的值也要改成 新的长度
                count = i - hashMap.get(s.charAt(i));
                //再将发生重复的字符对应的value更新下
                hashMap.put(s.charAt(i),i);
            }
        }
        return Math.max(max,count);
    }
}
```

> 改进思路:
>
> 滑动窗口，用两个指针标记当前字符串的大小
>
> ```java
> class Solution {
>     public int lengthOfLongestSubstring(String s) {
>         if(s.length() == 0) return 0;
>         HashMap<Character, Integer> map = new HashMap<Character, Integer>();
>         int max = 0;
>         int left = 0;
>         for(int i = 0; i < s.length(); i++){
>             if(map.containsKey(s.charAt(i))){
>                 left = Math.max(left,map.get(s.charAt(i)) + 1);
>             }
>             map.put(s.charAt(i),i);
>             max = Math.max(max, i - left + 1);
>         }
>         return max;
>     }
> }
> ```

>  思路二 ：动态规划 + 哈希表
>
> 