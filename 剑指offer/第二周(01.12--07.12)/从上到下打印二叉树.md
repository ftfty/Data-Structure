# 剑指offer 32 - I. 从上到下打印二叉树



### 题目地址：[从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)



### 题目描述：

>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。



### 解答方法：

#### 介绍

1. 二叉树不是树的特殊情况，是两种概念

2. 性质：

   - 第 i 层至多有 2^(i-1) 个结点

   - 深度为 K 的二叉树至多有 2^k - 1 个结点

   - 叶子数为 n0,度为 2 的结点数 为 n2...
     - n0 = n2 + 1
       - B = n - 1
       - B = n2 * 2 + n1 *1
       - n = n1 + n2 + n3

3. 完全二叉树： 与满二叉树中的编号为1~n的结点一一对用

4. 满二叉树：2^k - 1个结点（深度 k）

   - 具有 n 个结点的完全二叉树深度为[log2n] + 1

   - 对任一结点 i 有
     - 若 i = 1，则结点 i 是二叉树的根，无双亲 ； 若 i > 1,则双亲结点为： i/2
       - 若 2i > n ,则 i 为 叶子结点，无左孩子，或 其左孩子为2i
       - 若 2i + 1 > n ,则结点 i 无右孩子，否则其有孩子为 2i + 1;

5. 存储结构：

   - 顺序存储结构
   - 链式存储结构



#### 代码

1. 使用队列
   - 根节点入队
   - 队不为空循环，从队列中取出一个结点
   - 若它有左孩子，左孩子入队
   - 若它有右孩子，右孩子入队

```java
class Solution {
    public int[] levelOrder(TreeNode root) {
        if(root == null) return new int[]{};
        Queue<TreeNode> queue = new LinkedList<>();
        ArrayList<Integer> arr = new ArrayList<>();
        queue.add(root);
        while (!queue.isEmpty()){
            TreeNode temp ;
            temp = queue.poll();
            arr.add(temp.val);
            if(temp.left != null) queue.add(temp.left);
            if(temp.right != null) queue.add(temp.right);
        }
        int[] res = new int[arr.size()];
        for (int i = 0; i < arr.size(); i++) {
            res[i] = arr.get(i);
        }
        return res;
    }
}
```