# 剑指offer 50. 第一次只出现一次的字符



### 题目地址：[第一次只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)



### 题目描述：

>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。



### 解答方法：

1. 哈希表法

- 第一次遍历用哈希表存储值和下标的映射
- 通过之前看 hashmap put 操作，key的value不为null 则修改后返回 old value，否则返回null 这一特点将重复出现的字符，下标设置为 -1
- 因为hashmap是无序的，所以再次遍历，找到第一次出现的字符是哪一个

```java
class Solution {
    public char firstUniqChar(String s) {
        char res = ' ';
        boolean flag = true;
        HashMap<Character,Integer> map = new HashMap<>(s.length());
        for(int i = 0; i < s.length(); i++){
            if(map.put(s.charAt(i),i) != null){
                map.put(s.charAt(i),-1);
            }
        }
        for (int i = 0; i < s.length(); i++) {
            if(map.get(s.charAt(i)) == i){
                res = s.charAt(i);
                break;
            }
        }
        return res;
    }
}
```

>改进思路：
>
>- 将value 设置为Boolean类型，通过containsKey函数，就可以一次put，不需要判断
>
>  ```java
>  class Solution {
>      public char firstUniqChar(String s) {
>          HashMap<Character,Boolean> map = new HashMap<>(s.length());
>          for(int i = 0; i < s.length(); i++){
>              map.put(s.charAt(i),!map.containsKey(s.charAt(i)));
>          }
>          for (int i = 0; i < s.length(); i++) {
>              if(map.get(s.charAt(i)) == true){
>                  return s.charAt(i);
>              }
>          }
>          return ' ';
>      }
>  }
>  ```

> 思路二：有序的哈希表：linkedhashmap
>
> 思路三：字典数组
>
> ```java
> class Solution {
> public char firstUniqChar(String s) {
>      if(s.equals("")) return ' ';
>      int[] arr = new int[26];
>      for(int i = 0; i < s.length(); i++){
>          arr[s.charAt(i)-'a'] += 1;
>      }
>      for(int i = 0; i < s.length(); i++){
>          if(arr[s.charAt(i)-'a'] == 1) return s.charAt(i);
>      }
>      return ' ';
>     }
> }
> ```

