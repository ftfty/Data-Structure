# 剑指offer 53. 在排序数组中查找数字

### 题目地址：[在排序数组中查找数字](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)



### 题目描述：

>统计一个数字在排序数组中出现的次数。



### 解答方法：

1. 

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] == target) n++;
        }
        return n;
    }
}
```

2. 

```java
class Solution {
    public int search(int[] nums, int target) {
        if(nums.length == 0)return 0;
        int left = 0;
        int mid = 0;
        int count = 0;
        int right = nums.length - 1;
        while(left <= right){
            mid = (left + right)/2;
            if(nums[mid] < target){
                left = mid +1;
            }
            if(nums[mid] > target){
                right = mid -1;
            }
            if(nums[mid] == target){
               break;
            }
        }
        for (; left <= mid; left++) {
            if(nums[left] == target)break;
        }
        while (left < nums.length && nums[left] == target){
            count++;
            left++;
        }
        return count;
    }
}
```



>- 时间复杂度 O(log N)。
>- 空间复杂度 O(1)
>
>优化思路：
>
>1. 应用两次二分
>2. 找到左边界，和右边界
>
>3. target 的数量为 right - left - 1
>
>```java
>class Solution {
>    public int search(int[] nums, int target) {
>        return helper(nums, target) - helper(nums, target - 1);
>    }
>    int helper(int[] nums, int tar) {
>        int i = 0, j = nums.length - 1;
>        while(i <= j) {
>            int m = (i + j) / 2;
>            if(nums[m] <= tar) i = m + 1;
>            else j = m - 1;
>        }
>        return i;
>    }
>}
>```
>
>