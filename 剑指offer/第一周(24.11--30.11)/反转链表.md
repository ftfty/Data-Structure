# 剑指offer 24. 反转链表



### 题目地址：[反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)



### 题目描述：

>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。



### 解答方法：

1. 

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null) return head;
        Stack<ListNode> stack = new Stack<>();
        ListNode temp = new ListNode();
        while (head.next != null){
            stack.push(head);
            head = head.next;
        }
        stack.push(head);
        temp.val = stack.pop().val;
        temp.next = null;
        ListNode res = temp;
        while(!stack.isEmpty()){
            ListNode tmp = new ListNode();
            tmp.val = stack.pop().val;
            tmp.next = null;
            temp.next = tmp;
            temp = tmp;
        }
        return res;
    }
}
```

>评论中思路二：递归
>
>- 先走至链表末端的倒数第二个结点
>
>- head.next.next = head;
>
>- 指的是：如递归的最后一层：最后一个结点的next指向倒数第二个结点
>
>- head.next = null；
>
>- 然后防止环链，将其本来的next设为空
>
>  ```java
>  class Solution {
>      public ListNode reverseList(ListNode head) {
>          //如果head为空，或者只有head一个结点，则返回HEAD
>          if(head == null || head.next == null) {
>              return head;
>          }
>          //递归
>          ListNode node = reverseList(head.next);
>          head.next.next = head;
>          head.next = null;
>          return node;
>      }
>  }
>  ```
>
>![](images/反转列表_递归.gif)
>
>
>
>思路三：双指针
>
>- pre : 反转后链表的head结点
>
>- next： 记录cur的next，防止链表断掉
>
>- cur：指向原链表的每个结点
>
>- 
>
>  ```java
>  class Solution {
>      public ListNode reverseList(ListNode head) {
>          ListNode pre = null, cur = head, next = null;
>          while(cur != null) {
>              next = cur.next;
>              cur.next = pre;
>              pre = cur;
>              cur = next;
>          }
>          return pre
>      }
>  }
>  ```
>
>  ![](images/反转列表-16378433567922.gif)