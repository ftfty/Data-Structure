# 剑指offer 45. 把数组排成最小的数

### 题目地址：[把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)



### 题目描述：

>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。



### 解答方法：

1. 要建立新的比较规则
   - 若m+n>n+m -----> m>n
   - 若m+n<n+m -----> m<n
   - 若m+n=n+m -----> m=n
2. 根据规则进行排序，然后返回字符串

```java
//开始把 5-52-52 这种情况放在main函数中处理，改了好久总是考虑不全，看了题解，只要改比较器就好了。但是写的还是比较复杂
class Solution {
    public String minNumber(int[] nums) {
        if(nums == null)return "";
        int n = 0;
        boolean flag = false;
        String fin = "";
        String[] res = new String[nums.length];
        for (int i = 0; i < nums.length; i++) {
            res[i] = exchange(nums[i]);
        }
        quickSort(res,0,res.length - 1);
        for (int i = 0; i < res.length; i++) {
            fin += res[i];
        }
        return fin;
    }

    public void quickSort(String[] arr, int left, int right){
        if(left >= right) return;
        int l = left;
        int r = right;
        int mid = left;
        String temp = "";
        while(l < r) {
            while ((arr[mid]+arr[r]).compareTo(arr[r]+arr[mid]) <= 0 && l < r) {
                r--;
            }
            if ((arr[mid]+arr[r]).compareTo(arr[r]+arr[mid])> 0) {
                temp = arr[mid];
                arr[mid] = arr[r];
                arr[r] = temp;
            }
            while ((arr[mid]+arr[r]).compareTo(arr[r]+arr[mid]) >= 0 && l < r) {
                l++;
            }
            if ((arr[mid]+arr[r]).compareTo(arr[r]+arr[mid]) < 0) {
                temp = arr[mid];
                arr[mid] = arr[l];
                arr[l] = temp;
            }
            mid = left;
        }
        quickSort(arr,left,l-1);
        quickSort(arr,l+1,right);
    }

    public String exchange(int nums){
        LinkedList<Integer> list = new LinkedList<>();
        String num = "";
        if(nums == 0)list.addFirst(nums);
        while(nums != 0){
            list.addFirst(nums % 10);
            nums /= 10;
        }
        for (int i = 0; i < list.size(); i++) {
            num += list.get(i)+"";
        }
        return num;
    }
}
```

> 改进思路：
>
> - 改了比较器，就直接可以用Arrays的sort方法排序了
> - 单独写个exchange方法也很多余
>
> ```java
> class Solution {
>     public String minNumber(int[] nums) {
>         String[] strs = new String[nums.length];
>         String fin="";
>         for(int i = 0; i < nums.length; i++){
>             strs[i] = String.valueOf(nums[i]);
>         }
>         Arrays.sort(strs,(x,y) -> (x+y).compareTo(y+x));
>         for(int i = 0; i < strs.length; i++){
>             fin += strs[i];
>         }
>         return fin;
>     }
> }
> ```
>
> 