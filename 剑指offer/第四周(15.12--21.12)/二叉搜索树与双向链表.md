# 剑指offer 36. 二叉搜索树与双向链表

### 题目地址：[二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)



### 题目描述：

>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

### 解答方法：

1. 

```java
//当只有一个节点的时候，要指向自己！！！
class Solution {
    LinkedList<Node> list = new LinkedList<>();
    public Node treeToDoublyList(Node root) {
        if(root == null ) return root;
        LDR(root);
        if(list.size() == 1) {
            root.left = root;
            root.right  = root;
            return root;
        }
        for (int i = 0; i < list.size(); i++) {
            Node node = list.get(i);
            if(i == 0){
                node.left = list.getLast();
                node.right = list.get(1);
            }else if(i == list.size() - 1){
                node.right = list.getFirst();
                node.left = list.get(i - 1);
            }else{
                node.left = list.get(i - 1);
                node.right = list.get(i + 1);
            }

        }
        return list.getFirst();
    }
    public void LDR(Node root){
        if(root == null) return;
        if(root.left != null) LDR(root.left);
        list.add(root);
        if(root.right != null) LDR(root.right);
        return ;
    }
}
```

> 2. dfs
>
>    ```java
>    class Solution {
>        Node pre,head;
>        public Node treeToDoublyList(Node root) {
>            if(root == null) return root;
>            dfs(root);
>            head.left = pre;
>            pre.right = head; 
>            return head;
>        }
>        public void dfs(Node node){
>            if(node == null) return;
>            dfs(node.left);
>            if(pre == null) head = node;
>            else{
>                pre.right = node;
>            }
>            node.left = pre;
>            pre = node;
>            dfs(node.right);
>        }
>    }
>    ```
>
>    